{
  "README.html": {
    "href": "README.html",
    "title": "The Sunset Language | sunset-docs",
    "summary": "The Sunset Language This repository contains the documentation site of the Sunset Language."
  },
  "docs/dev/architecture.html": {
    "href": "docs/dev/architecture.html",
    "title": "Runtime architecture | sunset-docs",
    "summary": "Runtime architecture Module - A module comprising a number of logically grouped together SunsetFiles. SunsetFile - Contains plain text Sunset Language code Lexer - Converts code into Tokens Parser - Converts Tokens into an Abstract Syntax Tree composed of statement nodes Analyzer - Evaluates references and checks types within the AST Compiler - Compiles the AST into simplified instruction files that flatten out references Environment - Contains all compiled informatio See this page for more information the grammar of the Sunset Language."
  },
  "docs/dev/design-framework.html": {
    "href": "docs/dev/design-framework.html",
    "title": "Design framework | sunset-docs",
    "summary": "Design framework This page describes the design framework used to describe the capacity of elements and their checking against provided demands. Note The below is out of date, and will need to be updated based on what has currently been implemented. Abstract representation This diagram shows the proposed structure of the interfaces that make up the Element Design Framework. The section below shows how these are may be implemented for the Purlin design. A number of Generic types may be required to allow these to be implemented properly - for example a PurlinBendingCheck : ICheck should really only be able to contain PurlinCapacity : ICapacity and not just any ICapacity. This means that it may need to become ICheck<CapacityType, DemandType> where CapacityType : ICapacity and DemandType : IDemand, such that PurlinBendingCheck : ICheck<PurlinCapacity, PurlinDemand>. This might make future development a little bit more complicated. The framework is made up of the following interfaces ICheck - Checks a number of IDemands against a single ICapacity. There will likely need to be some kind of tree structure here, as some checks are dependent on later checks, e.g. combined actions. ICapacity - Calculates a capacity (e.g. bending capacity, shear capacity, axial capacity, etc.) based on an IElementProperty dependency that is injected into it. IDemand - An adaptor that converts some actions (may be user generated or come from an analysis process) into something that can be compared by an ICheck. ICheckResult - A result produced by an ICheck that includes reference to the IDemand and ICapacity, and can be printed to a reporting string (i.e. something that includes all the calculations performed and the results). The current proposal is to allow nesting of IChecks, but it may perhaps be better to have an ICheckResultAggregator interface that acts as a container for multiple checks. This depends on how the tree structure is implemented for complex checks. IElementProperty - All of the properties that may be changed by the user or automated design process, e.g. \\(I_x\\), \\(Z_x\\) etc. IElement - A pretty generic element that could represent a purlin, column, footing, etc. ICheckableElement - An element that contains one or many checks to be done. IDesignableElement - An extension of ICheckableElement that will optimise the element by selecting the best IProperty for the job out of a list. ? indicates that the member is nullable. classDiagram IElement o-- IDemand ICheck~CapacityType : ICapacity , DemandType : IDemand~ -- ICapacity~T as IElement~ ICheck~CapacityType : ICapacity , DemandType : IDemand~ -- ICheckResult ICheckableElement~CheckType : ICheck~ o-- ICheck IDesignableElement~CheckType : ICheck~ <|-- ICheckableElement~CheckType : ICheck~ IElement ICheckableElement~CheckType : ICheck~ <|-- IElement CheckableElement <|.. ICheckableElement~CheckType : ICheck~ DesignableElement <|.. IDesignableElement~CheckType : ICheck~ class CheckableElement{ ... } class DesignableElement{ ... } class IElement{ +Property : IElementProperty +Demands : IDemand } <<Interface>> IElement class ICheckableElement~CheckType : ICheck~{ -Checks : List~CheckType~ +AddCheck(CheckType) void +CheckSingle(CheckType) IResult +CheckAll() IResult } <<Interface>> ICheckableElement~CheckType : ICheck~ class IDesignableElement~CheckType : ICheck~{ +InitialProperty : IElementProperty +AvailableProperties : List<IElementProperty> +AddProperty(IDesignable) void +Design() ICheckResult? } <<Interface>> IDesignableElement~CheckType : ICheck~ class ICapacity~T : IElement~{ +Name : String +Element : T +Value : double +Calculate() void +PrintReport() string } <<Interface>> ICapacity class IDemand{ ... } <<Interface>> IDemand class ICheck~CapacityType : ICapacity , DemandType : IDemand~{ +Name : String +Results : List~ICheckResult~? +Capacity : CapacityType +Demands : List~DemandType~ -Checks : List~ICheck~? +AddCheck(ICheck) void +CheckSingle(DemandType) ICheckResult +CheckAll() List~ICheckResult~ } <<Interface>> ICheck~CapacityType : ICapacity , DemandType : IDemand~ class ICheckResult{ +Capacity : ICapacity +Demand : IDemand +Result : double +Pass : bool +Results : List~ICheckResult~ +PrintReport() string } <<Interface>> ICheckResult Things to consider Nested, complex checks will need to be implemented. This should be done with a tree structure (i.e. Composite Pattern), which is implemented above but has not been well considered."
  },
  "docs/dev/developer-documentation.html": {
    "href": "docs/dev/developer-documentation.html",
    "title": "Developer documentation | sunset-docs",
    "summary": "Developer documentation"
  },
  "docs/dev/grammar.html": {
    "href": "docs/dev/grammar.html",
    "title": "Grammar reference | sunset-docs",
    "summary": "Grammar reference This describes the grammar using an Extended Backus-Naur Form syntax. By default rules skip spaces but not new lines. Rules in ALLCAPS do not skip spaces. Grammar syntax () is a grouping \"\" string literals ... is a range | options ? is zero or one + is one or more * is zero or more Declarations The key statements that define create new identifiers. elementFile -> elementDeclaration* ; scriptFile -> ( ifStatement | variableAssignment )* ; elementDeclaration -> IDENTIFIER (\"(\" IDENTIFIER \")\")? \":\" NEWLINE \"inputs:\" NEWLINE inputAssignment* \"calculations:\" NEWLINE (ifStatement | variableAssignment)* end NEWLINE ; ifStatement -> (ifCompStatement | ifCondStatement) ; // Comparison statements have half of the condition after the if keyword and the remaining half // half on each new condition branch. It is similar in nature to a switch or match statement. ifCompStatement -> if IDENTIFIER \":\" NEWLINE ( comparisonOperator term \":\" NEWLINE variableAssignment* )* else \":\" NEWLINE variableAssignment * end NEWLINE ; ifCondStatement -> if expression \":\" NEWLINE ( else if expression \":\" NEWLINE variableAssignment* )* else \":\" NEWLINE variableAssignment* end NEWLINE ; variableAssignment -> variableProperties \"=\" ( expression | ifExpression | NEWELEMENT ) descriptionShorthand? referenceShorthand? NEWLINE metadataAssignment* NEWLINE ; inputAssignment -> variableProperties \"=\" ( value | NEWELEMENT ) descriptionShorthand? referenceShorthand? NEWLINE metadataAssignment* NEWLINE ; variableProperties -> ( IDENTIFIER ( \"<\" MULTISYMBOL \">\" )? | IDENTIFIERSYMBOL ) unit ; metadataAssignment -> \"s:\" MULTISYMBOL NEWLINE | \"d:\" STRING | \"l:\" STRING | \"r:\" STRING ; IDENTIFIERSYMBOL -> \"@\" ALPHA+ ALPHANUM* IDENTIFIERSUBSCRIPT ; IDENTIFIERSUBSCRIPT -> \"_\" ALPHANUM+ ; descriptionShorthand -> string ; Design notes: IDENTIFIERSYMBOL is used for quickly creating variable identifiers that are defined only by a symbol. They can only consist of letters, numbers and valid underscores to signify subscripts. Expressions Expressions are the parts of statements that evaluate to a value. ifExpression -> (ifCompExpression | ifCondExpression) ; ifCondExpression -> if expression \":\" NEWLINE expression NEWLINE ( else if expression \":\" NEWLINE expression NEWLINE )* else \":\" NEWLINE end NEWLINE ; ifCompExpression -> if IDENTIFIER \":\" NEWLINE ( comparisonOperator term \":\" NEWLINE expression NEWLINE )* else \":\" NEWLINE expression NEWLINE end NEWLINE ; listExpression -> \"[\" (expression ( \",\" expression )* )? \"]\" ; dictionaryExpression -> \"[\" keyValuePair ( \",\" keyValuePair )* \"]\" ; keyValuePair -> ( value | identifier ) \":\" expression ; expression -> logic_or ; logic_or -> logic_and ( \"or\" logic_and )* ; logic_and -> equality ( \"and\" equality )* ; equality -> comparison ( ( \"!=\" | \"==\" ) comparison )* ; comparison -> term ( ( \">\" | \">=\" | \"<\" | \"<=\" ) term )* ; term -> factor ( ( \"-\" | \"+\" ) factor )* ; factor -> power ( ( \"/\" | \"*\" ) power )* ; power -> unary ( \"^\" unary )* unary -> \"-\" unary | primary ; primary -> value | call | IDENTIFIER | ELEMENTPROPERTY | \"(\" expression \")\"; call -> identifier \"(\" positionalArguments \")\" ; Element properties Element properties are variables that exist within an element. namedArguments -> namedArgument (\",\" namedArgument)* ; positionalArguments -> argument (\",\" argument)* ; namedArgument -> identifier \":\" argument ; argument -> value | identifier ; NEWELEMENT -> IDENTIFIER (\"(\" (positionalArguments | namedArguments)? \")\") ; ELEMENTPROPERTY -> IDENTIFIER (\".\" IDENTIFIER)* ; Notes: You can't directly use an element's property without first assigning it to a variable. Units and values value -> NUMBER unit? ; unit -> \"{\" unitFactor \"}\" ; unitFactor -> unitPower ( ( \"/\" | \"*\" ) unitPower )* ; unitPower -> unitPrimary ( ( \"^\" ) (unitPrimary | NUMBER) )* ; unitPrimary -> \"(\" unitFactor \")\" | UNITKEYWORD Keywords Reserved words used in the language. IF -> \"if\" ; ELSE -> \"else\" ; END -> \"end\" ; UNITKEYWORD -> \"m\" | \"mm\" | ... ; \\\\ Include all unit keywords Lexical grammar Basic grammar used to lex the input. REFERENCE -> <any char except \"{\" or \"}\">+ ; multisymbol -> SINGLESYMBOL+ ; SINGLESYMBOL -> \"{\" SINGLESYMBOL \"}\" | LATEXWORD (SUBSCRIPT? | SUPERSCRIPT?)* ; SUBSCRIPT -> \"_\" SINGLESYMBOL ; SUPERSCRIPT -> \"^\" SINGLESYMBOL ; IDENTIFIER -> ( ALPHA | \"_\" ) ( ALPHANUMERIC | \"_\" )* ; STRING -> \"\\\"\" <any char except \"\\\"\" or NEWLINE>* \"\\\"\" ; MULTILINESTRING -> \"\\\"\\\"\\\"\" <any char except \"\\\"\\\"\\\"\">* \"\\\"\\\"\\\"\" ; LATEXWORD -> (ALPHA | \"*\" | \"'\" )+ ; ALPHANUMERIC -> ALPHA | DIGIT ; ALPHA -> \"a\" ... \"z\" | \"A\" ... \"Z\" ; COMMENT -> \"//\" <any char except NEWLINE>* NEWLINE ; REPORT -> \"///\" <any char except NEWLINE>* NEWLINE ; NUMBER -> (FLOAT | INTEGER) EXPONENT? ; EXPONENT -> (\"e\" | \"E\") (\"+\" | \"-\" )? (FLOAT | INTEGER) FLOAT -> DIGIT+ \".\" DIGIT+ ; INTEGER -> DIGIT+ ; DIGIT -> \"0\" ... \"9\" ; BOOLEAN -> \"true\" | \"false\" ; NEWLINE -> \"\\n\" | \"\\r\\n\" ;"
  },
  "docs/dev/repositories.html": {
    "href": "docs/dev/repositories.html",
    "title": "Repository structure | sunset-docs",
    "summary": "Repository structure The language, description and tooling are contained in a number of repositories in the Sunset organisation. These are specified in the below categories. Specification and documentation sunset-docs: Documentation and specification for the language. Execution sunset-dotnet: .NET implementation of the Sunset Language. Development tools sunset-tree-sitter: Tree sitter grammar for the Sunset Language. sunset-lsp: Language Server"
  },
  "docs/dev/syntax-highlighting.html": {
    "href": "docs/dev/syntax-highlighting.html",
    "title": "Syntax highlighting | sunset-docs",
    "summary": "Syntax highlighting The following code has been written for the Monaco editor to allow syntax highlighting specifically for the Sunset Language. To see it in action, go to the Monarch page. [!NOTE] This needs to be updated to take into account the new grammar. // Used in https://microsoft.github.io/monaco-editor/monarch.html for code coloring return { defaultToken: \"invalid\", units: [ \"kg\", \"ug\", \"g\", \"T\", \"m\", \"nm\", \"um\", \"mm\", \"km\", \"s\", \"ms\", \"min\", \"hr\", \"day\", \"month\", \"year\", \"rad\", \"deg\", \"Pa\", \"kPa\", \"MPa\", \"GPa\", \"N\", \"kN\", \"MN\", ], operators: [ \"=\", \"*\", \"+\", \"-\", \"/\", ], brackets: [ { open: \"{\", close: \"}\", token: \"delimiter.curly\" }, { open: \"[\", close: \"]\", token: \"delimiter.bracket\" }, { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" }, { open: \"<\", close: \">\", token: \"delimiter.angle\" }, ], tokenizer: { root: [ { include: \"@whitespace\" }, { include: \"@numbers\" }, // Units // TODO: Work out how to pick out only valid units [/\\[\\w*\\]/, \"tag\"], // Symbol shorthand // TODO: Work out how to allow ^ and {} in symbol names // @symbol [/@[a-zA-Z]\\w*/, \"type\"], // <symbol> [/<(\\\\?\\w*\\s?)*>/, \"type\"], // Reference shorthand // {reference} [/{.*}/, \"regexp\"], // Brackets [/[<>{}\\[\\]()]/, \"@brackets\"], // Operators [/[=+-/*]/, \"tag\"], // Keywords [/[a-zA-Z]\\w*/, { cases: { \"@units\": \"keyword\", \"@default\": \"identifier\", }, }], ], // Deal with white space, including single and multi-line comments whitespace: [ [/\\s+/, \"white\"], [/(^#{2}.*$)/, \"comment.doc\"], [/(^#.*$)/, \"comment\"], [/(^s:.*$)/, \"type\"], [/(^d:.*$)/, \"string\"], [/(^r:.*$)/, \"regexp\"], [/('''.*''')|(\"\"\".*\"\"\")/, \"string\"], ], // Recognize hex, negatives, decimals, imaginaries, longs, and scientific notation numbers: [ [/-?0x([abcdef]|[ABCDEF]|\\d)+[lL]?/, \"number.hex\"], [/-?(\\d*\\.)?\\d+([eE][+\\-]?\\d+)?[jJ]?[lL]?/, \"number\"], ], }, }; Examples An example script to be used for testing can be found below. Refer to the language description for more examples. ## #### Plate section modulus # The two \"##\"s at the beginning of the comment above is used to signal that it will be included in the report. # The \"#### \" following it means that a level 4 heading will be added as per standard Markdown. # This line and the two lines above will not be included in the report as they begin with only a single #. ## Calculate the **plastic** section modulus of the plate. # The **plastic** is Markdown for \"make 'plastic' bold\". @b = 150 [mm] d: Width of the plate. @t = 10 [mm] d: Thickness of the plate. plasticDenominator = 4 # This variable will not be reported as it does not have a symbol defined @Z_p {Example reference} = b * t ^ 2 / plasticDenominator d: Plastic section modulus."
  },
  "docs/user/conditionals.html": {
    "href": "docs/user/conditionals.html",
    "title": "| sunset-docs",
    "summary": "Conditionals Conditions are expressions that evaluate to a true or false variable. They tend to use the following operators: Value comparisons: == Equal to != Not equal to < Less than <= Less than or equal to > Greater than >= Greater than or equal to Type comparisons: is Types are equivalent is not Types are not equivalent Combinations: and, or not In-variable if statements A conditional can affect a single variable, where the calculations of a variable are interchanged depending on the result of a condition. These take one of two forms: Conditional form variable = if condition: expression else if condition: expression ... # Multiple else if statements allowable prior to else statement else: expression end metadata: values Comparison form variable = if variable: comparison: expression ... # Multiple comparison statments allowable prior to else statement else: expression end comparison can be a single comparison such as > 20 {mm} or can optionally include additional combined comparisons like > 20 {mm} or < 10 {mm} Rules: All of the expressions must evaluate to the same units or type. if statements are executed sequentially, and are exited once one of them is found to be true. There must be an else statement at the end of the statements. For example: @x = if y < 20 {mm}: A + B * C # Note that this must evaluate to {MPa}, as the other conditions all evaluate to the same units else if y < 30 {mm}: 35 {MPa} \"Description override for this particular branch\" {Reference override} else: 40 {MPa} d: Default description if not picked up in one of the branches r: Default reference if not picked up in one of the above branches end In comparison form: @x = if y: > 20 {mm}: A + B * C # Note that this must evaluate to {MPa}, as the other conditions all evaluate to the same units < 30 {mm}: 35 {MPa} \"Description override for this particular branch\" {Reference override} else: 40 {MPa} d: Default description if not picked up in one of the branches r: Default reference if not picked up in one of the above branches end Design notes: The colon at the end of the if, else if and else statements are not strictly necessary, but are put in place to simulate Python syntax, and to allow a user to transition across to more general programming languages more readily. The else if is used instead of a plain if for the sake of readability so that the if and end clearly show the limits of the entire condition block. The end statement is used to align with the multi-variable syntax noted below. Even without these, as the expressions are single lined the tab indentation is not required for parsing the overall syntax. Multi-variable if statements Conditional statements can also be used across a number of different variables should more complex calculations be required. The syntax for this is: element: inputs: ... calculations: ... if condition: variable = expression ... else if condition: variable = expression ... else: variable = expression ... end ... Rules: Both the conditional and comparison forms of conditional statements may be used. All non-anonymous variables must be defined in the same manner between each condition and must have the same dimensions in each of the conditions. Design notes: The end statement is required here to differentiate between the conditional block and the next variable definition below. Conditions on Options If an Option is provided as the variable in a comparison if statement, the else statement may be omitted if all the options are included in the comparisons. For example, the below is valid as all four options are included in the if statement comparisons.: options BoltTypes = [\"4.6/S\", \"8.8/S\", \"8.8/TB\", \"8.8/TF\"] ... if BoltTypes: is \"4.6/S\": ... is \"8.8/S\": ... is \"8.8/TB\": ... is \"8.8/TF\": ... end Design note: The aim in doing this is to prevent errors from creeping into the software as additional types are added in. One should explicitly implement behaviour for all options."
  },
  "docs/user/element-inheritance.html": {
    "href": "docs/user/element-inheritance.html",
    "title": "Element inheritance | sunset-docs",
    "summary": "Element inheritance Elements can inherit from other elements, copying the behaviour (the inputs and outputs) of that element and allowing it to be extended. For example, a reinforcement bar can be considered as having inherited from a circle. Circle: inputs: Diameter <\\phi> = 100 {mm} \"Diameter of the circle\" calculations: Area = (Pi * Diameter ^2) / 4 \"Area of the circle\" Reinforcement(Circle): inputs: Diameter = parent \"Diameter of the reinforcing bar\" calculations: Area = parent The element inheriting from the other element must explicitly inherit all the properties of the parent element, and either explicitly declare that they are as per the parent with the keyword parent, or they can override certain aspects of the parent by re-defining them. All inputs and calculations must be included in the child element for the sake of readability. Any elements that are not inherited from explicitly will throw an error. The intent of this is to encourage full consideration of the inherited properties and to encourage consideration of whether inherited properties are actually required. [!NOTE] Multiple inheritance was considered, but has been abandoned to allow for branching behaviour to be implemented. Interface-like behaviour is to be considered for multiple inheritance if required. Element groups Inherited elements can be grouped into categories to allow for the definition of inputs to contain a particular group of element types."
  },
  "docs/user/elements.html": {
    "href": "docs/user/elements.html",
    "title": "Elements | sunset-docs",
    "summary": "Elements Defining elements Elements are groups of expressions. Their definition consists of a name, one or many input variables and their default values and a series of expressions. The inputs are defined in an inputs: section and the calculations are defined in a calculations: section. The tabs are included for readability but are not strictly required. For example, a PadFooting element may be as below. PadFooting: inputs: Width <w> = 1199 {mm} \"Width of the footing\" Length <l> = 1599 {mm} \"Length of the footing\" Depth <d> = 799 {mm} \"Depth of the footing\" calculations: BearingArea <A_bearing> = w * l d: Bearing area of the footing on the ground Volume <V> = w * l * d d: Volume of the footing The default value of an input variable must be a constant or an element instantiated with constant parameters. As all elements have default values, all instantiated elements can be treated as constants. Instantiating elements Elements may be instantiated using default values only, with all parameters entered or with named parameters only and the remaining values as default. PadFootingDefault = PadFooting() # 1199x1600x800 footing PadFootingAll = PadFooting(1399 {mm}, 2400 {mm}, 900 {mm}) # 1400x2400x900 footing PadFootingNamed = PadFooting(Width: 1499 {mm}) # 1500x1600x800 footing Conditional execution of element calculations To conditionally execute calculations with an element, branch elements can be created. This allows elements to dynamically recast themselves to a child element based on certain parameters within them. Examples: Shear behaviour of beam sections [!NOTE] This may cause quite a lot of unexpected behaviour. Consider the difference between branch elements and inherited elements. If using inherited elements only, it may be necessary to prevent overrides of functions and the creation of new inputs in inherited elements (could result in too many rules for the user). This may be described by the Liskov Substitution Principle? One behaviour we have already used is with if statements, where the definition of functions changes depending on the output of another function. Can something similar be used for larger branching behaviour that allows code to be separated into different elements and files? ElementA { inputs { X = 35 {mm} } calculations { Y = 45 {mm} } } [!NOTE] Consider whether we should allow for conditional branches of execution within an element. For example, if a certain thing is true, do all of these calculations and if not don't do them. There may be some benefit to confining this for the purpose of readability and type checking, and using some form of sub-element behaviour if the behaviour is particularly hard to manage. As an example, think of slender vs. stocky concrete columns. Perhaps a this keyword could be used to reroute a particular element down to an inherited element if there are a lot of calculations that don't apply? Then some type checking can be done if necessary. Column: inputs: Slenderness = 20 this = if (Slenderness > 20: StockyColumn) else (SlenderColumn) Essentially use an if statement, where the element itself can be assigned as a child element. Consider how this might work with overridden behaviours - this may be starting to become needlessly complex. Perhaps there is something to be said about partial classes that continue on after the first class is reassigned? Sometimes you want to have common behaviour that uses the results of a particular class. Perhaps the best thing to do then is to be able to pass all of the inputs into another class at once Column: inputs: Slenderness = 20 calculations: ColumnBehaviour = if (Slenderness > 20): StockyColumn(inputs) else: SlenderColumn(inputs) This would only work if StockyColumn derives from Column only and doesn't introduce any additional inputs or other behaviours (otherwise you would end up with some uncontrolled default values). I think we just need to call this a partial element. You would almost never want to pass in Column branch StockyColumn: A = What about something like CHS vs UB shear behaviour in steel? There may just be a need for including partial behaviour into an element. Beam: ... match (Section == CHSSection): CHSBeam Beam branch CHSBeam: # Just continues on calculations from the previous beam Perhaps some of it is just: match (Section): is CHSSection: # Calculations for CHS beam X = CHSCalculationResultX Y = CHSCalculationResultY is UBSection: # Calculations for UB beam X = UBCalculationResultX Y = UBCalculationResultY And the compiler picks up if there are any dependencies on if branches that aren't common between all branches of the if statement. This is equivalent to: X = if (Section is CHSSection): CHSCalculationResultX else if (Section is UBSection): UBCalculationResultX Y = if (Section is CHSSection): CHSCalculationResultY else if (Section is UBSection): UBCalculationResultY A private modifier may be required here such that stronger type checking is imposed - i.e. all public calculations must be duplicated between the different match sections. The ability of an element to dynamically cast itself to a different element makes some sense - this way a Column instantiated with stocky properties is equivalent to a StockyColumn. That said there's not much point in doing this as one wouldn't want to instantiate a StockyColumn with regular SlenderColumn properties and create a logical error. Perhaps the best thing to do here is to treat branches instantiated with different behaviours as abstract types using a branch keyword as above. This should resolve itself to a match statement which then resolves to multiple if statements. Type checking is undertaken. This precludes the use of multiple inheritance, perhaps we should just copy the C# way of doing things and use single inheritance with multiple interfaces. Anonymous elements Anonymous elements group variables with dynamically generated inputs. To do this, create a new variable with an unused element name and the . operator. This will create an anonymous element that is nested within the current element."
  },
  "docs/user/functions-on-collections.html": {
    "href": "docs/user/functions-on-collections.html",
    "title": "Functions on collections | sunset-docs",
    "summary": "Functions on collections There are a number of functions that can be performed on collections that allow you to effectively loop over collections. These include the following: Lists Iterators array.foreach(expression) Returns an array where value and index are used as keywords Reducers array.min(), array.max(), array.average() array.where() array.select() Dictionaries Iterators dictionary.foreach(expression) [!NOTE] Add ability to iterate in a goal-seek like fashion using dictionaries"
  },
  "docs/user/getting-started.html": {
    "href": "docs/user/getting-started.html",
    "title": "Getting started | sunset-docs",
    "summary": "Getting started This page describes the Sunset Language, a simplified programming language used for engineering calculations. Comments Comments start with // and cause the remainder of a line to be ignored. // This is a comment, the contents of which is ignored by the interpreter/compiler. x = 35 {mm} y = 50 {N} // This is also a comment The preferred style is to have all comments on new lines with a space between the // character and the beginning of the comment. Units Units are physical units of measurement. The standard unit abbreviations can be used and are enclosed in square brackets {unit}, such as: {m} for metres {mm} for millimetres {s} for seconds {MPa} for megapascals Derived units are described using expressions containing the below operators. Standard order of operations applies. *, . or ``(at least one space) for multiplication / for division ^ for exponents For example, {mm^2}, {mm*mm}, {mm mm}, {mm.mm} are all equivalent, but not equal to {mmmm}. Units with different dimensions can be mixed using these operators. For example {kN/m} and {kN m^-1} are both equivalent. Parentheses can be used to group together operations. For example, {kg m/s^2} is not equivalent to {kg (m/s)^2}, as the latter will resolve to {kg m^2 / s^2}. Values Values are numbers that are optionally followed by a unit. The following are valid values: 40 // This is a 'unitless' value 12 {mm} 35 {kN m} 345,850.598 {kPa} A space is not required between the number and the unit, but is preferred. 12 {mm} // This is valid and preferred 35{kN m} // This is also valid but not preferred All commas are ignored when processing numbers, and en or En may be used to raise any number to the nth exponent. 12e5 // Equal to 1,200,000 12e-2 // Equal to 0.12 14,32.12 // Equal to 1,432.12 as all commas are ignored. Variables Variables are defined by assigning a variable or expression to a name. Names must start with a letter or underscore, and can contain any combination of letters, numbers and underscores. // Valid variable names length = 35 {mm} _duration = 2.5 {s} // Invalid variable names 3length = 35 {mm} // Starts with a number my variable = 68 {s} // Name contains a space my@variable = 45 {kg} // Name contains a non-alphanumeric character Variable metadata Metadata describing variables can be provided in the lines following a variable by starting the line with one of the below letters and a colon :. Each letter is for a specific piece of metadata. s: for symbols used in reporting calculations in LaTeX format. E.g. \\phi M_{sx} as the symbol \\(\\phi M_{sx}\\) d: for a description of the variable. E.g. The bending section capacity of the plate in the x axis. r: for a code reference of the variable. E.g. AS4100 Cl. 4.3.2 l: for a label to be used when the variable is included in a user interface. E.g. Bending capacity For example, the above variable may be annotated with metadata as follows: bendingCapacity = 1500 {kNm} s: \\phi M_{sx} d: The bending section capacity of the plate in the x axis. r: AS4100 Cl. 4.3.2 Tabs are recommended before the metadata descriptors for readability. Symbol shorthand Angle brackets <symbol> may be used as shorthand for the definition of a symbol following the declaration of a variable. // The following two definitions are equivalent, with the second using the symbol definition shorthand width = 150 {mm} s: b d: The width of the plate. width <b> = 150 {mm} d: The width of the plate. If the symbol doesn't contain any spaces, it may be used as an alternative to the name in the following calculations. width <b> = 150 {mm} d: The width of the plate. thickness <t> = 10 {mm} d: The thickness of the plate. // The following two expressions are equivalent area <A> = b * t area <A> = width * thickness If a symbol can just be used as a name (i.e. it doesn't contain any invalid characters), it may be defined as a name by starting the name with @. // Given a variable in which the name is not required: width <b> = 150 {mm} // Using just the symbol but starting with @ makes both the symbol and name equal @b = 150 {mm} // This cannot be used for any variable where the symbol cannot be later used as a name // For example, for the following variable bending_capacity <\\phi M> = 0.9 // This cannot be defined as `@\\phi M` as it is not a valid name for later calculations due to the space in the symbol Description shorthand Double quotation marks \" may be used as shorthand for the description following the declaration of a variable. The order of the description and the reference do not matter, however convention is for the reference to be placed first. // The following two definitions are equivalent, // with the second using the description definition shorthand capacity_factor = 250 {MPa} \"The yield strength of steel.\" s: \\phi r: AS4100 Cl. 2.5.4 Calculations To perform calculations, simply use the following operators and functions to form expressions assigned to a variable. + for addition - for subtraction * for multiplication / for division ^ for exponents sqrt(x) for square roots sin(x), cos(x), tan(x) for standard trigonometric functions. asin(x), acos(x), atan(x) for standard inverse trigonometric functions // Variable definitions with values width <b> = 150 {mm} d: The width of the plate. thickness <t> = 10 {mm} d: The thickness of the plate. // Calculations are performed by assigning an expression to a variable area <A> = width * thickness \"The cross sectional area of the plate.\" // More variables may be defined with values after a calculation is performed capacityFactor <\\phi> = 0.9 yieldStrength <f_y> = 250 {MPa} // Calculations may be performed based on the results of previous calculations bendingCapacity <\\phi M_sx> = capacity_Factor * f_y * A d: The axial capacity of the section r: AS4100 Cl. 4.5.3 Reassigning units Occasionally, units must be reassigned after the calculation. This tends to occur when empirical formulae are used. This can be done by assigning units to a variable using {unit}, which converts the value back to a unitless number, then using {unit} again to convert the result to the desired unit. compressiveStrength <f^'_c> = 32 {MPa} # The following empirical formula will result in flexuralStrength being assigned the units {MPa^0.5} or {kg^0.5 / (m^0.5 s^1)} flexuralStrength <f^'_{ct.f}> = 0.6 * sqrt(compressiveStrength) # Results in 3.39 {kg^0.5 / (m^0.5 s^1)} Instead, the compressive strength must be converted to a unitless value before the square root: compressiveStrengthUnitless = compressiveStrength {MPa} # Results in 32 with no units # Note that it is important to get the units right here, as the following would be an error: compressiveStrengthUnitless = compressiveStrength {kPa} # Results in 32,000 with no units # To avoid confusion, we recommend that _unit is used for any variables that are converted to a unitless quantity compressiveStrength_MPa = compressiveStrength {MPa} Once this conversion is done, the flexural strength can be calculated in a unitless form then converted back to the correct units: flexuralStrength_MPa = 0.6 * sqrt(compressiveStrength_MPa) # Results in 3.39 with no units flexuralStrength <f^'_{ct.f}> = flexuralStrength_MPa {MPa} # Results in 3.39 {MPa} This can be shortened to a single expression to avoid creating the additional compressiveStrength_MPa and flexuralStrength_MPa variables. compressiveStrength <f^'_c> = 32 {MPa} flexuralStrength <f^'_{ct.f}> = 0.6 * sqrt(compressiveStrength {MPa}) {MPa} Reporting Performing calculations will result in a report being generated in the format of choice. The most common format is Markdown, which can be used to then output PDF reports. Text Comments with a single # are not included in the report. If ## is used to start a comment, it is included in the report. Standard Markdown can be used to style the comment. Calculations Variables are reported if a symbol is defined for that variable, but are not reported if a symbol is not defined. If a reference is defined it will also be added to the report next to the calculation. All variables with a description will be printed at the end of the calculation with their description. ## #### Plate section modulus # The two \"##\"s at the beginning of the comment above is used to signal that it will be included in the report. # The \"#### \" following it means that a level 4 heading will be added as per standard Markdown. # This line and the two lines above will not be included in the report as they begin with only a single #. ## Calculate the **plastic** section modulus of the plate. # The **plastic** is Markdown for \"make 'plastic' bold\". @b = 150 {mm} d: Width of the plate. @t = 10 {mm} d: Thickness of the plate. plasticDenominator = 4 # This variable will not be reported as it does not have a symbol defined @Z_p {Example reference} = b * t ^ 2 / plasticDenominator d: Plastic section modulus. This will result in the following report: Calculation of the plastic section modulus Calculate the plastic section modulus of the plate. \\[ > \\begin{alignedat}{2} > b &= 150 \\text{ mm} \\\\ > d &= 10 \\text{ mm} \\\\ > Z_p &= 3,750 \\text{ mm}^2 &\\quad\\text{(Example reference)} > \\end{alignedat} > $$ Where: - $b$: Width of the plate. - $d$: Thickness of the plate. - $Z_p$: Plastic section modulus. (Example reference) \\] Types of variables A variable can take on any of the following types: Constants Expressions Elements Conditionals Lists Dictionaries Constants A constant can be a single value or an expression that evaluates to a number of constants. # Single value constant YieldStrength <f_y> = 250 {MPa} \"The yield strength of steel.\" # Expression containing multiple constants Area <A> = 100 {mm} * 30 {mm} \"Cross-sectional area of plate.\" # Expression that evaluates to a constant AxialCapacity <N> = f_y * A \"Axial capacity of plate.\" Expressions Expressions are described in the section above on calculations. Elements as variables in other elements Elements can also be used as variables in other elements. If we wanted to calculate the elastic capacity of a section, we might define some elements as below: Section: inputs: Width <w> = 10 {mm} Depth <d> = 100 {mm} Area <A> = w * d @I_xx = w * d^3 / 12 IsotropicMaterial: inputs: YieldStrength <f_y> = 300 {MPa} Density <\\rho> = 7800 {kg / m^3} Beam: inputs: Section = Section() Material = IsotropicMaterial(YieldStrength: 250 {MPa}) AxialCapacity <N> = Section.Area * Material.YieldStrength BendingCapacity <M> = Section.I_xx * Material.YieldStrength Weight <w> = Section.Area * Material.Density Note that for elements used as variables, they do not need to define a symbol as there is no straightforward way of printing them to the screen. [!NOTE] Consider whether they should be provided with a symbol or some kind of name for the purpose of reporting and UI generation. The variables within an element can be accessed with the . modifier. Roadmap Still to be described [x] Branching element behaviour [x] Conditionals [ ] Arrays and dictionaries [ ] Collection functions [ ] Options [ ] Error handling [ ] Comparisons Implementation [ ] Variables and expressions [ ] Elements [ ] Conditionals [ ] Arrays [ ] Collection functions [ ] Dictionaries [ ] Options"
  },
  "docs/user/options.html": {
    "href": "docs/user/options.html",
    "title": "Options | sunset-docs",
    "summary": "Options Options are special key-constant pairs. They can be defined as a new type with the following: BoltTypes = Options( 4.6/S: \"Grade 4.6, snug tight\", 8.8/S: \"Grade 8.8, snug tight\", 8.8/TB: \"Grade 8.8, tensioned bearing\", 8.8/TF: \"Grade 8.8, tensioned friction\")"
  },
  "docs/user/overview.html": {
    "href": "docs/user/overview.html",
    "title": "Overview | sunset-docs",
    "summary": "Overview This page provides an overview of the Sunset calculation framework. This framework was created to handle: Unit checking and conversions Calculations involving quantities Reporting Design of elements In addition to the base framework, the Sunset Language has been created as a simple way of expressing design calculations."
  },
  "docs/user/quantities.html": {
    "href": "docs/user/quantities.html",
    "title": "Quantities and calculations | sunset-docs",
    "summary": "Quantities and calculations Quantities are used to describe certain physical quantities, which may have both a value and a unit of measurement. For example, the quantity 150 kg has a value of 150 and a unit of kilograms. The behaviour of these quantities is described in the IQuantity interface and mostly implemented in the Quantity class. To create a new quantity, simply provide a value and unit of measurement to the constructor. var mass = new Quantity(150, Unit.Kilograms); Calculations The Quantity class contains a number of mathematical functions (in the Quantity.Operators.cs file) and the operator overloads, such that the following arithmetic operations will automatically convert the units and calculate resulting units when standard operators are used. var mass = new Quantity(150, Unit.Kilograms); Note Ongoing work required to document the Sunset framework."
  },
  "docs/user/reporting.html": {
    "href": "docs/user/reporting.html",
    "title": "Reporting | sunset-docs",
    "summary": "Reporting Performing calculations will result in a report being generated in the format of choice. The most common format is Markdown, which can be used to then output PDF reports. Text Comments with a single # are not included in the report. If ## is used to start a comment, it is included in the report. Standard Markdown can be used to style the comment. Calculations Variables are reported if a symbol is defined for that variable, but are not reported if a symbol is not defined. If a reference is defined it will also be added to the report next to the calculation. All variables with a description will be printed at the end of the calculation with their description. ## #### Calculation of the plastic section modulus # The two \"##\"s at the beginning of the comment above is used to signal that it will be included in the report. # The \"#### \" following it means that a level 4 heading will be added as per standard Markdown. # This line and the two lines above will not be included in the report as they begin with only a single #. ## Calculate the **plastic** section modulus of the plate. # The **plastic** is Markdown for \"make 'plastic' bold\". @b = 150 {mm} d: Width of the plate. @t = 10 {mm} d: Thickness of the plate. plasticDenominator = 4 # This variable will not be reported as it does not have a symbol defined @Z_p {Example reference} = b * t ^ 2 / plasticDenominator d: Plastic section modulus. This will result in the following report: Calculation of the plastic section modulus Calculate the plastic section modulus of the plate. \\[ > \\begin{alignedat}{2} > b &= 150 \\text{ mm} \\\\ > d &= 10 \\text{ mm} \\\\ > Z_p &= 3,750 \\text{ mm}^2 &\\quad\\text{(Example reference)} > \\end{alignedat} > $$ Where: - $b$: Width of the plate. - $d$: Thickness of the plate. - $Z_p$: Plastic section modulus. (Example reference) \\]"
  },
  "docs/user/units.html": {
    "href": "docs/user/units.html",
    "title": "Units | sunset-docs",
    "summary": "Units This page describes how units work in the Sunset framework. These units are based on the International System of Units as closely as they can be followed, with some additional dimensions added for convenience. Terminology Dimensions Dimensions describe the different physical dimensions that a unit can possess. These include the standard SI dimensions: Time Length Mass Electric current Thermodynamic temperature Amount of a substance Luminous intensity It also includes a number of non-standard dimensions for convenience, such as: Angle, included to allow for angles to be expressed with a symbol despite being dimensionless. The dimensions are enumerated in the DimensionName enumeration. The dimension information specific to a particular unit is stored in an array of Dimension objects, with length equal to the number of dimensions in DimensionName. Unit types There are four different types of units within the framework. These are: Unit NamedUnit which inherits Unit NamedUnitMultiple which inherits NamedUnit BaseUnit which inherits NamedUnit Unit describes any general purpose unit that does not necessarily have a strict physical meaning. For example, this could be a unit such as \\(kg m^2 s^{-1} K\\), which has no immediate physical meaning but must be representable as a unit. This class implements most of the behaviour of the units, and is divided into a number of different partial classes. NamedUnit describes a unit that has a specific single name, and is used to describe what are common units. This includes Newtons. The names for all named units including multiples and base units is in the UnitName enumeration. NamedUnitMultiple is a specific type of NamedUnit, where the unit has a name but is a multiple of what would be considered the coherent named unit. For example, a Newton is a NamedUnit but a Kilonewton is a NamedUnitMultiple. BaseUnit is a type of named unit where it describes only a single dimension. For example, a Metre is a BaseUnit as it describes a unit in only one Dimension (Length). Usage Generally, units are created through mathematical operations on quantities that are assigned simple base or named units initially. This is described in the next section on calculations. All of the named units enumerated in UnitName are described in the Unit.BaseUnits.cs file as static instances, such that the following will retrieve the metre base unit. var unit = Unit.Metre;"
  },
  "docs/user/user-guide.html": {
    "href": "docs/user/user-guide.html",
    "title": "User guide | sunset-docs",
    "summary": "User guide Getting started Basic syntax Creating functions Other articles What is Sunset? Why Sunset? A comparison with Excel and Python"
  },
  "docs/user/variables.html": {
    "href": "docs/user/variables.html",
    "title": "Types of variables | sunset-docs",
    "summary": "Types of variables A variable can take on any of the following types: Constants Expressions Elements Conditionals Lists Dictionaries Anonymous Temporary variables are defined using the character ? at the beginning of the line. These variables are not accessible to be used in external calculations, but are useful for providing intermediate calculation steps. In the below example, the numerator and denominator variables are used to calculate the result but are defined as anonymous variables and are not reported or included in any future calculations. They cannot be accessed from outside the element that they are defined in, if they are defined in an element. ?numerator = x / 35 ?denominator = y / 40 Result <r> = numerator / denominator Constants A constant can be a single value or an expression that evaluates to a number of constants. # Single value constant YieldStrength <f_y> = 250 {MPa} \"The yield strength of steel.\" # Expression containing multiple constants Area <A> = 100 {mm} * 30 {mm} \"Cross-sectional area of plate.\" # Expression that evaluates to a constant AxialCapacity <N> = f_y * A \"Axial capacity of plate.\" Expressions Expressions are described in the Fundamentals section. Elements As variables in calculations Elements can be instantiated as variables The variables within an element can be accessed with the . modifier. As variables in other elements Elements can also be used as variables in other elements. If we wanted to calculate the elastic capacity of a section, we might define some elements as below: Section: inputs: Width <w> = 10 {mm} Depth <d> = 100 {mm} Area <A> = w * d @I_xx = w * d^3 / 12 IsotropicMaterial: inputs: YieldStrength <f_y> = 300 {MPa} Density <\\rho> = 7800 {kg / m^3} Beam: inputs: Section = Section() Material = IsotropicMaterial(YieldStrength: 250 {MPa}) AxialCapacity <N> = Section.Area * Material.YieldStrength BendingCapacity <M> = Section.I_xx * Material.YieldStrength Weight <w> = Section.Area * Material.Density Note that for elements used as variables, they do not need to define a symbol as there is no straightforward way of printing them to the screen. [!NOTE] Consider whether they should be provided with a symbol or some kind of name for the purpose of reporting and UI generation. Conditionals Variables can take on different values depending on whether certain conditions are met in the code. See Conditionals for more information. Lists Lists contain zero or more variables within them. They are defined using square brackets [ and ], with items separated with commas. All items within a list must be of the same type. They are expressed as: reinforcementDiameters = [12 {mm}, 16 {mm}, 20 {mm}, 24 {mm}, 28 {mm}, 32 {mm}, 36 {mm}, 40 {mm}] Items within a list can be accessed using square brackets notation list[index : integer], and the first and last elements can be accessed using the .first() and .last() functions respectively. See the other collection functions for more information on how to iterate over lists. Dictionaries Dictionaries are lists of key-value pairs. They are also defined with square brackets, with each item defined as a key : value pair and separated with commas. All keys must be of the same type and all values must be of the same type, but they do not have to match. windSpeed = [\"A2\" : 45 {m/s}, \"B1\" : 52 {m/s}] Items within a dictionary can be accessed similar to those within a list. See the other collection functions for more information on how to iterate over dictionaries. Other features of dictionaries: Linear interpolation between keys: dict[~key] Finding the value just below the key: dict[~key-] Finding the value just above the key: dict[~key+] Goal seek style iteration syntax to be confirmed"
  },
  "index.html": {
    "href": "index.html",
    "title": "The Sunset Language | sunset-docs",
    "summary": "The Sunset Language The Sunset Language is a programming language that has been designed for engineering calculations. It aims to bring the power of programming languages to create complex re-usable calculations to people who have little to no experience with programming. This site is structured into a user guide which contains tutorials on how to use the language, and developer documentation which contains information on the design of the language and associated tooling. What is Sunset (for non-programmers) Sunset is a simple programming language that has been carefully designed for people with little to no programming experience to be able to write high quality calculations that are reusable, reliable and beautifully presented. What is Sunset (for programmers) Sunset is a strong, static typed functional programming language and associated tooling that has been designed for people with little to no programming experience. The language has multiple compilation targets, ranging from libraries that can be used to create custom user interfaces to PDFs that contain all of the resulting calculations. It is strongly typed to catch more errors in calculations as the calculations are being written. The language features units of measurement as static types that are generated and checked during the compilation process. Unit conversions are automatically handled at runtime when they are valid. It is a functional language, as the concepts of state and data structures are often difficult for non-programmers to grasp initially. Spreadsheets contain functional programming languages in their cell formulas, and many non-programmers familiar with creating spreadsheets will intuitively understand many of the concepts. Target audience The target audience of the Sunset Language are people: Who have some experience with Microsoft Excel, Google Sheets or any other similar spreadsheet software. The minimum experience required is the ability to create cell functions for mathematical calculations. Who wish to perform repetitive calculations and report on the results of the calculations. Who do not necessarily have any experience with programming other than the creation of spreadsheet cell formulas. Goals The goals of the Sunset Language are therefore: To bring the power of composable software to non-programmers. To bring modern programming tooling to non-programmers."
  }
}